# H5 It's Alive!

## Mikä on GNU-Debugger?

## Asennus
- `sudo apt-get install gdb`
<img width="528" height="41" alt="image" src="https://github.com/user-attachments/assets/f5131c2a-4c0a-4295-ba28-6e49917f02a7" />

## Lab 0
`wget https://terokarvinen.com/application-hacking/lab0.zip`
`cd Lataukset`
`unzip lab0.zip`

- Kokeillaan ajaa ohjelma  `./buggy_program`

<img width="510" height="129" alt="image" src="https://github.com/user-attachments/assets/4fce2317-e935-4cc1-a58c-fb2f838b25ea" />

- Näyttää hieman oudolta, katsotaan GNU-debuggerilla

<img width="832" height="246" alt="image" src="https://github.com/user-attachments/assets/59ecc4aa-fc63-487d-afe5-7870e31ec903" />

- Aloitin tutkimisen `gdb buggy_program` -> `(gdb) l` listatakseni ohjelman
- Huomataan, että `<= size` tekee ylimääräisen silmukan. Ohjelmassa on 5 alkiota ja niiden indeksit tulisi olla 0, 1, 2, 3, 4. Nyt ohjelma lukee taulukon yli numerolla 5 ja tulostaa 0.
- Ohjelmassa alkioiden määrään viittaa `size` muuttuja. Kun ehto on `<= size` `i` lukee tällöin arvot 0, 1, 2, 3, 4, 5, josta viimenen on taulukon ulkopuolella.
- Jos merkin muuttaa "on pienempi kuin merkkiin" `<` logiikka muuttuu, `i < size` eli i on pienempi kuin alkioiden määrä. Tälloin kun size on `5` niin i käy läpi arvot 0, 1, 2, 3, 4 kaikki mitkä ovat pienempiä kuin 5.

Korjataan:
- `nano buggy_program.c`

<img width="704" height="20" alt="image" src="https://github.com/user-attachments/assets/1973a88e-ff79-4561-a164-957d9a3708ae" />

- Recompile

<img width="549" height="22" alt="image" src="https://github.com/user-attachments/assets/7075c4a1-62f0-4e06-8d09-ae3cc674632c" />

<img width="450" height="226" alt="image" src="https://github.com/user-attachments/assets/8eaf8e09-7aa6-4a15-831d-1c604ef5ab81" />

- Nyt kun ajetaan niin ohjelma toimii oikeanlaisesti.

## a) Lab 1

Tarkoituksena tutkia ohjelmaa ja löytää vika, sitten korjata se.

- Aluksi unzippasin ladatun lab tehtävän `unzip lab1.zip` ja tutkin mitä tiedosto pitää sisällään

<img width="369" height="45" alt="image" src="https://github.com/user-attachments/assets/2333a7b4-df5a-4fd0-93bc-3d65b6142ed4" />

- Huomataan `gdb_example1` ohjelma, sekä sen C-kielinen tiedosto, sekä Makefile. Keskitytään nyt noihin kahteen `gdb_exampl1` tiedostoihin.
- Kokeilin ajaa ohjelman `./gdb_example1`, mutta se antoi virheilmoituksen "Muistialueen ylitys" & "Khoor/#zruog1". Huomataan ettei ohjelma toimi kunnolla. Aloitetaan GNU-debuggaus.
<img width="464" height="63" alt="image" src="https://github.com/user-attachments/assets/eb4f6e0f-1954-480d-be1e-d4705bd5be1c" />

- Käännetään ohjelma debuggausta varten `gcc -g -Wall -Wextra gdb_example1.c` -> `a.out` niminen tiedosto.
<img width="654" height="58" alt="image" src="https://github.com/user-attachments/assets/176eff05-1307-4062-8077-fb97f1f3596a" />

- Ajetaan tiedosto GNU-debuggerilla `gdb ./a.out` ja tutkitaan millainen ohjelma kyseessä `l` = "list"-komennolla
<img width="450" height="273" alt="image" src="https://github.com/user-attachments/assets/2b74a70a-2a4b-4dee-881b-abadf5153b73" />

- Huomataan´, rivi 14, jossa `char * bad_message =NULL;`, luulen että ohjelman vika johtuu kyseisestä muuttujasta. Kokeilaan ajaa ohjelmaa `r`-komennolla.
<img width="689" height="184" alt="image" src="https://github.com/user-attachments/assets/6073f4b4-5827-41b6-b57f-6616f545a1f6" />

- Ohjelma sai signaalin `SIGSEGV`, `Segmentation fault.`. Ohjelma kaatuu kohdassa `print_scrambled (message=0x0)`, joka näyttäytyy Null parametrina rivissä 7. 
- Tutkin asiaa netistä ja löysin selityksen signaalille. Ohjelma yrittää lukea tiettyä muistialuetta, johon sillä ei ole pääsyä tai sitä ei ole olemassa.
- Otin Text User Interface-tilan käyttöön `TUI enable`, jotta nähdään samanaikaisesti missä kohtaa ohjelmakoodia ollaan liikkumaassa, laitoin breakpointin riville 14, jossa `NULL` parametri on laadittuna. Sitten ajoin ohjelman GNU-debuggerissa `r`-komennolla ja ohjelma pysähtyy asettamaan breakpoint kohtaan.

<img width="735" height="482" alt="image" src="https://github.com/user-attachments/assets/52c7d148-4059-4502-8f5a-8074bcfb3e7e" />

- Käytin komentoa `n` = next liikkuakseni eteenpäni rivi riviltä. Parin askelluksen jälkeen ohjelma tulosti `Khoor/#zruog1`, eli ensimmäinen tulostus onnistui, mutta sen jälkeen ohjelma terminoituu SIGSEV, Segmentation faultin seurauksena. Huomataan, että rivin 17. jälkeen, ohjelma siirtyy `print_srambled(bad_message);` kohtaan ja ohjelmakoodissa bad_message on laadittu `char * bad_message = NULL;` eli `0x0` 

<img width="734" height="439" alt="image" src="https://github.com/user-attachments/assets/a8d074a6-f7bc-4146-b3e6-8912d9047d0f" />

- Asetin uuden breakpointin riviin 18 ja ajoin ohjelman uudelleen GNU-debuggerissa, nyt tässä breakpointissa astuin rivin sisälle `step` komennolla, sitten liikuin eteenpäin, kunnes SIGSEV ilmestyy ja katsoin backtrace komennolla `bt` syyt.
<img width="740" height="136" alt="image" src="https://github.com/user-attachments/assets/7b4ecad7-6ab7-4827-9c2d-1cb77019a9a1" />

- Backtrace näyttää, että kaatuminen tapahtuu funktiossa `print_scrambled` rivillä 7. Main funktio kutsuu tätä rivillä 18.

- Korjataan `Null` osoitin niin, että kirjoitetaan siihen vain jotain. Laitoin itse merkkijono "Fixaus" sitten tallensin tiedoston ja recompilesin sen `gcc -g -o korjattu? gdb_example1.c`

<img width="385" height="90" alt="image" src="https://github.com/user-attachments/assets/4acd43dc-8074-4745-a32e-83ac33e42c4f" />

<img width="724" height="147" alt="image" src="https://github.com/user-attachments/assets/737b2e71-37db-43c6-90aa-12eb22a816b0" />

<img width="454" height="59" alt="image" src="https://github.com/user-attachments/assets/47c9cf48-1822-415e-a269-b3c168f09065" />

- Ohjelma palauttaa oudolta näyttävän merkkijonon, sillä se siirtää määritellyn merkkijono jokaista kirjainta 3. merkkiä eteenpäin eli ASCII-arvoa 3. eteenpäin. Huomataan koodin kohdasta:

<img width="316" height="120" alt="image" src="https://github.com/user-attachments/assets/515f43b9-50ae-4067-b222-1df71a1edeb9" />

## b) Lab 2.

Tämän läbin tarkoituksena on löytää salasana ja lippu, sekä raportoida tehtäväratkaisusta.

- Katsotaan millainen ohjelma kyseessä
- `./passtr`

<img width="494" height="80" alt="image" src="https://github.com/user-attachments/assets/7fe80f15-0179-4ded-9e25-10ba5a902e0f" />

- Ohjelma vaatii salasanan, jotta saadaan flägi esiin, viedään ohjelma GNU-debuggeriin

- Nyt ohjelmaa ei voinut listata, joten kokeilin `info functions`

  <img width="421" height="327" alt="image" src="https://github.com/user-attachments/assets/77f4db4b-7b63-42c7-8449-27e00dae4edb" />

- Huomataan funktiot `check_password` ja `main` nämä funktiot ovat todennäköisesti tehtävänratkaisunkannalta merkittävimmät

- Kokeillaan disassembloida funktio main, että nähdään tarkemmin ohjelman kulku ja suoritusjärjestys

<img width="942" height="777" alt="image" src="https://github.com/user-attachments/assets/6b997659-d059-46eb-8d42-568f1c3c039c" />

- `Call` funktiot kutsuvat useaan otteeseen muita funktiota. `puts@plt` tulostaa kysymyksen, sitten ohjelma lukee syötteen `__isoc99_scanf@plt`, tämän jälkeen ohjelma kutsuu `mAsdf3a` funktiota. Kohdassa `main+153` määrittyy se meneekö argumentti onnistumispolkuun, jolloin flägi tulisi esiin.

- Tutkitaan kaikkia `call` funktiota ja asetetaan neljälle funktiolle breakpointit

<img width="324" height="153" alt="image" src="https://github.com/user-attachments/assets/5113cc63-6c86-4641-b0a1-2a0d869cc6f6" />

- Ajetaan nyt ohjelma ja tutkitaan ohjelman kulkua break pointtien välillä

<img width="500" height="187" alt="image" src="https://github.com/user-attachments/assets/c0d556af-3a12-4e43-b52a-1744ad5c1108" />

- Ohjelman ajon jälkeen laitoin vain jonkun salasanana tässä tilanteessa `aaaa` ja huomataan, että ohjelma hyppää heti breakpoint 4. `mAsdf3a`. Tämä funktio on siis keskeinen salasanan tarkistuksen kannalta

- Disassemblataan funktio `mAsdf3a` 


FLÄGI! <img width="640" height="156" alt="image" src="https://github.com/user-attachments/assets/f5020be1-a4c6-44e8-b4ab-56d107d2e383" />

SALASANA: <img width="625" height="99" alt="image" src="https://github.com/user-attachments/assets/9eb7c122-1631-4ab1-b5aa-cbde5e8ca6ff" />


## c) Nora crackmes

### Crackme03.

- Alkuun tutustuin tehtävään ja huomasin vinkeistä radare työkalun, jonka kloonasin tehtävähakemistooni, siirryin `radare2` hakemistoon ja asensin radare2:n komennolla `sys/install.sh`

<img width="867" height="149" alt="image" src="https://github.com/user-attachments/assets/a84cf067-ddc2-446d-907d-ca5e6c0ee0ad" />

<img width="569" height="43" alt="image" src="https://github.com/user-attachments/assets/dea1357e-78a2-406b-9804-fb3e35e73c22" />

<img width="957" height="93" alt="image" src="https://github.com/user-attachments/assets/dc9fc534-ff5e-4515-96f2-1a3be756f518" />

- Katsoin tehtäväohjeistusta ja bongasin sieltä "auto analyze" kohdan´, jossa sanottiin, että automaattisen analyysin voi suorittaa komennoilla `aaaa` ja `afl`

<img width="759" height="597" alt="image" src="https://github.com/user-attachments/assets/409ff004-105f-4e37-9cf3-6a716c973527" />

- Olenaissimmat funktiot tehtävän ratkaisun kannalta ovat main, sekä check_pw funktiot ohjeiden perusteella. Rupesin siis tutkimaan aluksi maini funktiota
- Siirryin funktioon komennolla `s main`, jonka jälkeen otin visuaalisen näkymän päälle `VV` komennolla. Nyt päästään tutkimaan ohjelmaa visuaalisella tasolla. Huomataan punaiset langat `f` eli "false", tämä näyttää miten ohjelma jatkaa kulkemista, kun argumentti on epätosi, kun taas vihreä lanka `t` eli true, miten ohjelma etenee kun argumentti on tosi.

<img width="918" height="649" alt="image" src="https://github.com/user-attachments/assets/5664e674-dd90-45d0-a701-13ec847956ce" />

- Ohjeistuksissa kehotettiin etsimään kohta, missä ohjelma päätyy virhetulostukseen ja niihin oli kaksi tarkistuspolkua

<img width="455" height="253" alt="image" src="https://github.com/user-attachments/assets/a712856f-59a0-4927-afae-7db9c2d413f9" />

- Tämä blokki `0x11df` näyttää antavan outputin "No..." katsotaan tarkemmin mitkä tarkastukset tähän johtaa

- Blokki `0x1197` on string lenght eli pituustarkistus. Syöte hylätään, jos syötteen pituus ei ole tasan 6

<img width="322" height="394" alt="image" src="https://github.com/user-attachments/assets/d2073ed8-a02a-4341-a80d-6c2d87f0d538" />

- Toinen tarkistusblokki on `0x11c9`, joka on check_pw eli sisältötarkistus.
- Voidaan päätellä, jos pituustarkistus onnistuu se hyppää suoraan virhetulostukseen, jos taas sisältötarkistus epäonnistuu se hyppää suoraan virhetulostukseen.

<img width="672" height="60" alt="image" src="https://github.com/user-attachments/assets/5e102df4-ffa5-4059-9e43-90cfe823ac6a" />

- Salasana on 6 merkkinen merkkijono, joten otetaan kuusi ensimmäistä tavua eli `02, 03, 02, 03, 05, 00`
- Lasketaan password[i] = correct[i] + mask[i] (ASCII-muodossa)
- Katsoin CyberChefillä muunnokset merkkijonosta "lAmBdA" hexaksi
  
<img width="581" height="497" alt="image" src="https://github.com/user-attachments/assets/7ffeff40-9c7c-42d6-bc79-3cca7655baef" />

- saadaan tuloste `6c 41 6d 42 64 41`
- Tehdään todiste lasku eli äskeiseen hexa jonoon lisätään tavut, jotka saimme selville aikaisemmin
- 6c + 02 = 6e
- 41 + 03 = 44
- 6d + 02 = 6f
- 42 + 03 = 45
- 64 + 05 = 69
- 41 + 00 = 41

<img width="609" height="547" alt="image" src="https://github.com/user-attachments/assets/1bd40f1a-a0e3-43ea-8650-ede36cbc80fd" />

- Saadaan merkkijono `nDoEiA`, kokeillaan toimiiko

<img width="630" height="48" alt="image" src="https://github.com/user-attachments/assets/20059e77-8e93-4436-908b-eeb60eadf021" />

- Vau toimi!

### Crackme04.

- Mennään seuraavaan carckme tehtävään 04. Tässä tehtävässä tulen myös hyödyntämään ohjeita, kuten edellisessä
- Avataan `crackme04.c` radare2 työkalulla `r 2./crackme04.64`
- Tehdään analyysit `aaaa`
- Listataan funktiot `afl`
- Tutkitaan main funktiota `s main` ja sitten `pdf`

<img width="711" height="217" alt="image" src="https://github.com/user-attachments/assets/231ff896-74e2-457a-b5d1-0ff1e5b10023" />

- Ohjeiden mukaan kyseistä looppia tulee tarkastella
- Loopin toiminta perustuu siihen, että se vertailee merkkejä ja laskee samalla summaa, sekä pituutta. Ohjelma vertaa laskurin arvoa arvoon `0x10` ja plussaa arvoon 0x6e2 eli desimaaleina se on juuri 1762.

<img width="413" height="79" alt="image" src="https://github.com/user-attachments/assets/6f294cb8-7254-40b6-9a40-d1382946768a" />

- `cmp edi, 0x10` tässä kohtaa `0x10` heksana on 16 desimaalia.
- Tarvitsemme siis 16-merkkiä pituisen jonon, jonka summa on 1762
- Ohjeiden mukaisesti jos jaetaan 1762/16 = 110,125
- Kirjain `n` on luku 110 ASCII-koodina. Lasketaan 110 * 16 = 1760, vielä puuttuu 2.
- Lisätään luku 2. ASCII-koodi taulukossa `n`-kirjaimeen, 110+2 = 112 ASCII-taulukossa siis kirjain`p`
- Saadaan salasanaksi: nnnnnnnnnnnnnnnp

<img width="688" height="40" alt="image" src="https://github.com/user-attachments/assets/638225f6-a8a8-49f2-b59a-99b6d09ff4f6" />




























# Lähteet:
- https://www.youtube.com/watch?v=1RrGVHF97Gs
- https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')&input=NmUgNDQgNmYgNDUgNjkgNDE
- 
